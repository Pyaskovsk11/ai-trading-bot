
# Стратегия разработки AI Трейдинг-Бота в Cursor AI с использованием внутреннего AI-агента

Этот документ описывает стратегию поэтапной разработки AI трейдинг-бота с использованием внутреннего AI-агента в среде Cursor AI. Цель — максимально эффективно использовать возможности AI для генерации кода, опираясь на ранее подготовленную проектную документацию.

## 1. Подготовка проекта и структуры папок в Cursor AI

Перед тем как начать генерировать код с помощью AI-агента Cursor, важно правильно настроить структуру вашего проекта. Это обеспечит организованность и упростит навигацию как для вас, так и для AI-агента.

**Действия в Cursor AI:**

1.  **Создание корневой папки проекта**:
    *   В Cursor AI создайте новую папку для вашего проекта, например, `ai_trading_bot`.
    *   Откройте эту папку как ваш текущий проект в Cursor.

2.  **Создание основной структуры каталогов**: Используя файловый менеджер Cursor (или команды в терминале Cursor), создайте следующую структуру папок внутри `ai_trading_bot/`, как было определено в документе `architecture_analysis.md`:

    ```
    ai_trading_bot/
    ├── app/                  # Backend приложение (FastAPI)
    │   ├── api/              # API эндпоинты
    │   ├── services/         # Бизнес-логика, стратегии
    │   ├── db/               # Работа с базой данных, ORM модели
    │   └── utils/            # Вспомогательные утилиты
    ├── telegram_bot/         # Логика Telegram-бота
    ├── webapp/               # Frontend приложение (React) - можно создать позже, если фокус на backend
    ├── docker/               # Dockerfile'ы и docker-compose.yml
    ├── tests/                # Тесты (pytest)
    ├── .vscode/              # Для настроек Cursor/VSCode (создастся автоматически)
    ├── .venv/                # Виртуальное окружение Python (рекомендуется)
    ├── requirements.txt      # Зависимости Python
    ├── .gitignore            # Файл для исключения ненужных файлов из Git
    └── README.md             # Основная документация проекта
    ```

3.  **Создание начальных файлов**:
    *   Внутри `app/` создайте пустой файл `main.py`.
    *   В корневой папке проекта создайте пустые файлы: `requirements.txt`, `README.md`.
    *   Создайте файл `.gitignore`. Вы можете попросить AI-агента Cursor сгенерировать стандартный `.gitignore` для Python-проекта, или использовать следующий базовый шаблон:
        ```gitignore
        # Byte-compiled / optimized / DLL files
        __pycache__/
        *.py[cod]
        *$py.class

        # C extensions
        *.so

        # Distribution / packaging
        .Python
        build/
        develop-eggs/
        dist/
        downloads/
        eggs/
        .eggs/
        lib/
        lib64/
        parts/
        sdist/
        var/
        wheels/
        pip-wheel-metadata/
        share/python-wheels/
        *.egg-info/
        .installed.cfg
        *.egg
        MANIFEST

        # PyInstaller
        #  Usually these files are written by a python script from a template
        #  before PyInstaller builds الْمُسْتَخْرَجَات executable, so they are not needed.
        *.manifest
        *.spec

        # Installer logs
        pip-log.txt
        pip-delete-this-directory.txt

        # Unit test / coverage reports
        htmlcov/
        .tox/
        .nox/
        .coverage
        .coverage.*
        .cache
        nosetests.xml
        coverage.xml
        *.cover
        .hypothesis/
        .pytest_cache/

        # Translations
        *.mo
        *.pot
        *.log

        # Django stuff:
        *.log
        local_settings.py
        db.sqlite3
        db.sqlite3-journal

        # Flask stuff:
        instance/
        .webassets-cache

        # Scrapy stuff:
        .scrapy

        # Sphinx documentation
        docs/_build/

        # PyBuilder
        target/

        # Jupyter Notebook
        .ipynb_checkpoints

        # IPython
        profile_default/
        ipython_config.py

        # pyenv
        .python-version

        # PEP 582; __pypackages__
        __pypackages__/

        # Celery stuff
        celerybeat-schedule
        celerybeat.pid

        # SageMath parsed files
        *.sage.py

        # Environments
        .env
        .venv
        env/
        venv/
        ENV/
        env.bak/
        venv.bak/

        # Spyder project settings
        .spyderproject
        .spyproject

        # Rope project settings
        .ropeproject

        # mkdocs documentation
        /site

        # mypy
        .mypy_cache/
        .dmypy.json
        dmypy.json

        # Pyre type checker
        .pyre/
        ```

4.  **Настройка виртуального окружения Python**:
    *   Настоятельно рекомендуется использовать виртуальное окружение для управления зависимостями проекта.
    *   В терминале Cursor (убедитесь, что он указывает на корневую папку проекта `ai_trading_bot`):
        ```bash
        python3 -m venv .venv  # Создать виртуальное окружение в папке .venv
        source .venv/bin/activate # Активировать окружение (для Linux/macOS)
        # Для Windows: .venv\Scripts\activate
        ```
    *   После активации убедитесь, что Cursor использует интерпретатор Python из вашего `.venv`.
        Обычно Cursor автоматически предлагает выбрать интерпретатор, или это можно сделать через палитру команд (Ctrl+Shift+P или Cmd+Shift+P) -> "Python: Select Interpreter".

5.  **Инициализация Git (рекомендуется)**:
    *   Если вы планируете использовать систему контроля версий, инициализируйте Git-репозиторий:
        ```bash
        git init
        git add .
        git commit -m "Initial project structure"
        ```

После выполнения этих шагов ваш проект в Cursor AI будет готов к тому, чтобы вы начали наполнять его кодом с помощью AI-агента, опираясь на созданную нами документацию и следующую поэтапную стратегию.




## 2. Поэтапная стратегия реализации модулей с использованием AI-агента Cursor

Рекомендуется двигаться от foundational-компонентов к более высокоуровневым, обеспечивая, чтобы каждый новый модуль мог опираться на уже созданные и протестированные части. Используйте ранее созданные нами документы (`database_design.md`, `module_logic_and_business_processes.md`, `api_and_interface_design.md` и т.д.) как основу для ваших запросов к AI-агенту Cursor.

**Этап 1: Настройка Backend (FastAPI) и Базы Данных (PostgreSQL)**

1.  **Модели Базы Данных (`app/db/models.py`)**:
    *   **Задача**: Создать SQLAlchemy модели для таблиц `Users`, `XAI_Explanations`, `Signals`, `Trades`, `News_Articles`, `Signal_News_Relevance` (как описано в `database_design.md`).
    *   **Промпт для AI-агента Cursor (пример)**: "Создай файл `app/db/models.py`. Используя SQLAlchemy, определи следующие модели базы данных PostgreSQL, основываясь на документе `database_design.md`: [приведите здесь краткое описание полей для каждой таблицы или сошлитесь на конкретные разделы документа]. Убедись, что есть все необходимые импорты, первичные ключи, внешние ключи и типы данных."
    *   **Фокус**: Корректность типов данных, связей (relationships), имен таблиц и полей.

2.  **Конфигурация Базы Данных и сессии (`app/db/session.py` или в `app/main.py` для начала)**:
    *   **Задача**: Настроить подключение к PostgreSQL и создать механизм для управления сессиями SQLAlchemy.
    *   **Промпт**: "Создай файл `app/db/session.py`. Напиши код для инициализации движка SQLAlchemy (engine) для подключения к PostgreSQL, используя строку подключения из переменной окружения `DATABASE_URL`. Также создай фабрику сессий (`SessionLocal`) и функцию зависимости (`get_db`) для использования в FastAPI эндпоинтах."

3.  **Базовая структура FastAPI приложения (`app/main.py`)**:
    *   **Задача**: Инициализировать FastAPI приложение, подключить роутеры (пока пустые), настроить CORS (если необходимо).
    *   **Промпт**: "В файле `app/main.py` создай экземпляр FastAPI. Добавь базовый эндпоинт `/` для проверки работоспособности. Подготовь место для подключения роутеров из `app/api/`. Настрой CORS, чтобы разрешить все источники (для разработки)."

4.  **Pydantic Схемы (`app/schemas/`)**:
    *   **Задача**: Создать Pydantic модели для валидации данных API запросов и ответов (как описано в `api_and_interface_design.md`). Создавайте их по мере необходимости для каждого эндпоинта.
    *   **Промпт (для `Signal` схем)**: "Создай файл `app/schemas/signal.py`. Определи Pydantic модели `SignalBase`, `SignalRead`, `SignalDetailsRead` на основе документа `api_and_interface_design.md` [приведите описание полей или сошлитесь]. Убедись, что `orm_mode = True` в Config для моделей чтения."

**Этап 2: Реализация API эндпоинтов (CRUD операции для основных сущностей)**

Начните с простых CRUD (Create, Read, Update, Delete) операций для ваших моделей, чтобы убедиться, что взаимодействие с БД работает корректно.

1.  **API для Пользователей (Whitelist) (`app/api/users.py` и `app/services/user_service.py`)**:
    *   **Задача**: Реализовать эндпоинты для управления пользователями из белого списка (создание, чтение, обновление статуса, удаление). Это может быть полезно для раннего тестирования доступа.
    *   **Промпт для сервиса**: "Создай файл `app/services/user_service.py`. Напиши функции для создания пользователя, получения пользователя по ID или telegram_id, обновления статуса whitelist и удаления пользователя. Используй сессию SQLAlchemy (`db: Session`) и Pydantic схемы из `app.schemas.user`."
    *   **Промпт для API**: "Создай файл `app/api/users.py`. Реализуй FastAPI роутер с эндпоинтами POST `/users/`, GET `/users/`, PUT `/users/{user_id}/whitelist_status/`, DELETE `/users/{user_id}/`, используя функции из `user_service.py` и соответствующие Pydantic схемы. Не забудь про зависимость `get_db`."
    *   **Подключение роутера**: В `app/main.py` подключите созданный роутер.

2.  **API для Новостей (`app/api/news.py` и `app/services/news_service.py`)**:
    *   **Задача**: Реализовать эндпоинты для добавления (симуляция, пока нет RAG) и чтения новостей.
    *   **Процесс**: Аналогично `users.py`, создайте сервис и API эндпоинты для новостей.

**Этап 3: Реализация основной бизнес-логики (Сбор данных и Технический Анализ)**

1.  **Модуль Технических Индикаторов (`app/utils/indicators.py`)**:
    *   **Задача**: Реализовать функции для расчета RSI, MACD, EMA и определения свечных моделей. Вы можете использовать библиотеки, такие как `TA-Lib` (потребуется ее установка и добавление в `requirements.txt`).
    *   **Промпт (для RSI)**: "В файле `app/utils/indicators.py` напиши функцию для расчета RSI, принимающую на вход список цен (например, pandas Series). Если используешь `TA-Lib`, импортируй ее. Добавь обработку ошибок для недостаточного количества данных."

2.  **Сервис Технического Анализа (`app/services/technical_analysis_service.py`)**:
    *   **Задача**: Сервис, который использует функции из `indicators.py` для анализа данных по активам.
    *   **Промпт**: "Создай `app/services/technical_analysis_service.py`. Напиши класс или функции, которые принимают ценовые данные (OHLCV) для актива и возвращают рассчитанные значения индикаторов (RSI, MACD, EMA) и определенные свечные модели, используя `app.utils.indicators`."

3.  **Сервис Сбора Данных (заглушки) (`app/services/data_collection_service.py`)**:
    *   **Задача**: Создать заглушки для функций сбора данных с BingX, Arkham, Lookonchain. На этом этапе они могут возвращать тестовые (mock) данные.
    *   **Промпт**: "В `app/services/data_collection_service.py` создай функции-заглушки: `fetch_bingx_prices(asset_pair: str)`, `fetch_arkham_data(asset_pair: str)`, `fetch_lookonchain_data(asset_pair: str)`. Пока они могут возвращать предопределенные тестовые данные в ожидаемом формате."

**Этап 4: Интеграция RAG и XAI модулей**

1.  **Сервис RAG-анализа (заглушка или базовая интеграция) (`app/services/rag_analysis_service.py`)**:
    *   **Задача**: Интегрировать Hector RAG. Если прямой интеграции пока нет, создайте заглушку, которая имитирует ответ от RAG-модуля.
    *   **Промпт (заглушка)**: "Создай `app/services/rag_analysis_service.py`. Напиши функцию `analyze_news_with_hector_rag(news_text: str)`, которая имитирует ответ от Hector RAG: возвращает словарь с полями `affected_assets`, `sentiment_score`, `summary`."

2.  **Модуль XAI-объяснений (`app/utils/xai.py`)**:
    *   **Задача**: Реализовать генерацию текстовых объяснений на основе шаблонного подхода (как описано в `ai_rag_integration_recommendations.md`).
    *   **Промпт**: "В `app/utils/xai.py` создай функцию `generate_xai_explanation(signal_data: dict)`, которая принимает словарь с данными о сигнале (значения индикаторов, новостной фон и т.д.) и генерирует человекочитаемое объяснение на основе шаблона. [Приведи пример шаблона из документации]."

3.  **Сервис XAI (`app/services/xai_service.py`)**:
    *   **Задача**: Сервис, который использует `xai.py` для генерации и сохранения объяснений.
    *   **Промпт**: "Создай `app/services/xai_service.py`. Напиши функцию `create_and_save_xai_explanation(signal_factors: dict, db: Session)`, которая использует `generate_xai_explanation` из `app.utils.xai`, сохраняет объяснение в таблицу `xai_explanations` и возвращает ID созданной записи."

**Этап 5: Реализация основного цикла генерации сигналов**

1.  **Сервис Управления Рисками (`app/utils/risk_management.py` и `app/services/risk_management_service.py`)**:
    *   **Задача**: Реализовать логику расчета размера позиции и стоп-лосса.
    *   **Процесс**: Аналогично предыдущим сервисам, сначала утилиты, потом сервис.

2.  **Сервис Генерации Сигналов (`app/services/signal_generation_service.py`)**:
    *   **Задача**: Центральный сервис, который объединяет данные от ТА, RAG, Smart Money (пока заглушки), применяет риск-менеджмент и XAI для формирования и сохранения сигнала.
    *   **Промпт**: "Создай `app/services/signal_generation_service.py`. Напиши основную функцию `generate_signal_for_asset(asset_pair: str, db: Session)`. Эта функция должна: 
        1. Получить ценовые данные (используя заглушку из `data_collection_service`).
        2. Выполнить технический анализ (используя `technical_analysis_service`).
        3. Получить анализ новостей (используя заглушку `rag_analysis_service`).
        4. (Опционально) Получить данные Smart Money (заглушка).
        5. На основе этих данных и предопределенных правил (опиши простые правила для начала) сформировать предварительный сигнал.
        6. Применить риск-менеджмент (используя `risk_management_service`).
        7. Если сигнал одобрен, сгенерировать XAI-объяснение (используя `xai_service`) и сохранить объяснение.
        8. Сохранить сигнал (с `xai_explanation_id`) в таблицу `signals`.
        9. (Опционально) Залогировать симулированную сделку в таблицу `trades`.
        Вернуть созданный сигнал или None, если условия не выполнены."

3.  **API для Сигналов и Сделок (`app/api/signals.py`, `app/api/trades.py`)**:
    *   **Задача**: Реализовать эндпоинты для чтения сигналов и сделок, как описано в `api_and_interface_design.md`.

**Этап 6: Планировщик (`app/utils/scheduler.py`)**

1.  **Задача**: Настроить `APScheduler` для периодического запуска задач (например, `generate_signal_for_asset` для отслеживаемых активов).
2.  **Промпт**: "Создай `app/utils/scheduler.py`. Используй `APScheduler` для создания фонового планировщика. Добавь задачу, которая будет периодически (например, каждые 5 минут) вызывать функцию `generate_signal_for_asset` из `signal_generation_service` для списка предопределенных активов. Обеспечь передачу сессии БД в эту функцию. Планировщик должен запускаться при старте FastAPI приложения (можно добавить вызов в `app/main.py`)."
    *   *Примечание*: Учитывайте ограничение на выполнение запланированных задач в моей среде. Этот код будет для вашей локальной среды или EC2.

**Этап 7: Telegram-бот (`telegram_bot/`)**

1.  **Базовая структура бота (`telegram_bot/bot.py`)**:
    *   **Задача**: Инициализировать бота (например, с использованием библиотеки `python-telegram-bot`), настроить обработчики для команд `/start`, `/status`, `/signal`, `/summary`.
    *   **Промпт**: "Создай файл `telegram_bot/bot.py`. Используя `python-telegram-bot`, напиши код для Telegram-бота. Бот должен:
        1. Инициализироваться с токеном из переменной окружения `TELEGRAM_BOT_TOKEN`.
        2. Обрабатывать команды: `/start` (приветствие), `/status` (запрос к `GET /api/v1/status/` вашего FastAPI), `/latest_signal` (запрос к `GET /api/v1/signals/?limit=1`), `/summary` (запрос к `GET /api/v1/summary/general/`).
        3. Форматировать и отправлять ответы пользователю."

**Этап 8: Frontend (React) (`webapp/`) - если необходимо на данном этапе**

*   Разработку Frontend можно вести параллельно или после стабилизации Backend API. Используйте `api_and_interface_design.md` для определения, какие данные и как отображать.
*   AI-агент Cursor также может помочь с генерацией React-компонентов, запросов к API, управлением состоянием.

**Этап 9: Docker-конфигурации (`docker/`, `docker-compose.yml`)**

1.  **Задача**: Создать `Dockerfile` для backend и frontend, а также `docker-compose.yml` для локального запуска всех сервисов (как описано в `deployment_and_scaling.md`).
2.  **Промпт**: "Создай `docker/backend.Dockerfile` для FastAPI приложения на Python 3.10 с uvicorn. Создай `docker/frontend.Dockerfile` для React-приложения на Node 18. Создай `docker-compose.yml` для запуска backend, frontend и PostgreSQL базы данных, связывая их и настраивая порты и переменные окружения, как в документе `deployment_and_scaling.md`."

**Этап 10: Тестирование (`tests/`)**

*   Параллельно с разработкой каждого модуля, просите AI-агента Cursor помочь написать `pytest` тесты.
*   **Промпт (для сервиса)**: "Напиши pytest тесты для функции `create_user` в `app/services/user_service.py`. Используй моки для сессии БД. Проверь успешное создание пользователя и обработку ошибок (например, если пользователь уже существует)."

Эта поэтапная стратегия должна помочь вам системно подойти к разработке, используя AI-агент Cursor для генерации кода на каждом шаге. Не забывайте предоставлять агенту как можно больше контекста из ранее созданных документов.



## 3. Рекомендации по работе с AI-агентом Cursor и формулированию промптов

Эффективное взаимодействие с AI-агентом Cursor — ключ к быстрой и качественной разработке. Вот несколько советов, как формулировать запросы (промпты) для получения наилучших результатов:

1.  **Будьте конкретны и ясны**:
    *   Избегайте двусмысленных или слишком общих запросов. Чем точнее вы опишете, что вам нужно, тем лучше будет результат.
    *   **Плохой промпт**: "Сделай API для сигналов".
    *   **Хороший промпт**: "Создай файл `app/api/signals.py`. Реализуй FastAPI роутер. Добавь эндпоинт `GET /signals/` для получения списка торговых сигналов. Используй Pydantic схему `SignalRead` из `app.schemas.signal` для ответа. Функция должна принимать параметры пагинации `skip: int = 0` и `limit: int = 100`. Данные должны извлекаться с помощью функции `get_signals(db: Session, skip: int, limit: int)` из `app.services.signal_service` (эту функцию мы создадим позже). Не забудь про зависимость `get_db`."

2.  **Предоставляйте контекст**:
    *   **Ссылайтесь на существующие документы**: Упоминайте ранее созданные нами документы (`database_design.md`, `api_and_interface_design.md` и т.д.) или их конкретные разделы. AI-агент Cursor может использовать открытые в IDE файлы как контекст.
    *   **Ссылайтесь на существующий код**: Если вы просите доработать существующий файл или использовать функции из других модулей, укажите это явно.
    *   **Пример**: "В файле `app/services/signal_service.py`, доработай функцию `generate_signal_for_asset`. После получения результатов от `technical_analysis_service`, добавь вызов функции `analyze_news_with_hector_rag` из `app.services.rag_analysis_service` для получения оценки новостного фона. Результат сохрани в переменную `news_sentiment`."

3.  **Разбивайте сложные задачи на более мелкие**:
    *   Не пытайтесь сгенерировать целый сложный модуль одним промптом. Лучше разбить задачу на несколько логических шагов.
    *   **Пример**: Вместо "Напиши весь `signal_generation_service.py`", используйте последовательные промпты: "Создай структуру класса `SignalGenerationService` в `app/services/signal_generation_service.py`", затем "Добавь метод для получения ценовых данных в класс `SignalGenerationService`", и так далее.

4.  **Указывайте структуру и формат вывода**:
    *   Если вы ожидаете определенную структуру кода (например, класс с конкретными методами, функцию с определенными аргументами), укажите это.
    *   Если вам нужен код на определенном языке или с использованием конкретных библиотек, уточните это (хотя для Python в FastAPI проекте это обычно подразумевается).

5.  **Используйте AI-агента для рефакторинга и улучшения кода**:
    *   После генерации кода, вы можете попросить AI-агента его улучшить: "Проанализируй этот код на предмет возможных улучшений производительности" или "Предложи, как можно сделать этот код более читаемым".
    *   "Рефактори эту функцию, чтобы она следовала принципу DRY".

6.  **Просите объяснить сгенерированный код**:
    *   Если какая-то часть сгенерированного кода вам непонятна, попросите AI-агента ее объяснить: "Объясни, пожалуйста, как работает эта часть кода и почему ты выбрал такой подход".

7.  **Итерируйте и уточняйте**:
    *   Редко первый же сгенерированный вариант будет идеальным. Будьте готовы уточнять свой запрос, исправлять ошибки в сгенерированном коде (с помощью AI или вручную) и просить AI-агента переделать или дополнить код.
    *   **Пример**: "В предыдущем ответе ты использовал X, но я бы хотел, чтобы ты использовал Y. Пожалуйста, перепиши функцию с этим изменением."

8.  **Указывайте на конкретные файлы и директории**:
    *   Всегда четко указывайте, в каком файле или директории должен быть создан или изменен код. Это помогает AI-агенту лучше ориентироваться в проекте.
    *   **Пример**: "Создай новый файл `app/schemas/trade.py` и определи в нем Pydantic модели для сделок."

9.  **Используйте возможности Cursor AI по работе с кодовой базой**:
    *   Cursor AI может анализировать вашу кодовую базу. Вы можете задавать вопросы о существующем коде или просить сгенерировать новый код, который будет интегрироваться с уже написанным.
    *   **Пример**: "В моем проекте есть сервис `app.services.user_service`. Какие методы он предоставляет? Напиши пример использования метода `get_user_by_telegram_id`."

10. **Четко формулируйте ожидания по обработке ошибок и крайним случаям**:
    *   **Пример**: "При написании функции для получения данных с внешнего API, добавь обработку исключений для случаев сетевых ошибок или если API возвращает некорректный статус код. В случае ошибки функция должна логировать ее и возвращать None."

11. **Просите сгенерировать документацию и комментарии**:
    *   "Добавь docstrings к этой функции, объясняющие ее назначение, аргументы и возвращаемое значение."
    *   "Прокомментируй сложные участки этого кода."

Применяя эти рекомендации, вы сможете значительно ускорить процесс разработки и получить от AI-агента Cursor более качественный и релевантный код, который будет хорошо вписываться в архитектуру вашего проекта.



## 4. Советы по организации тестирования и итеративной доработки кода, сгенерированного AI

Код, сгенерированный AI-агентом, даже при хороших промптах, требует тщательной проверки, тестирования и возможной доработки. Это критически важный этап для обеспечения качества и надежности вашего AI трейдинг-бота.

1.  **Не доверяйте слепо сгенерированному коду**:
    *   Всегда рассматривайте код от AI как черновик или отправную точку.
    *   Внимательно читайте и анализируйте каждую строку, чтобы понять логику и убедиться, что она соответствует вашим ожиданиям и требованиям безопасности.

2.  **Пишите тесты (и просите AI помочь)**:
    *   **Unit-тесты**: Для каждой функции или метода, особенно в бизнес-логике (`services/`) и утилитах (`utils/`), пишите unit-тесты с использованием `pytest`.
        *   **Промпт для AI**: "Для функции `calculate_rsi(prices: list) -> float` в файле `app/utils/indicators.py` напиши несколько pytest тестов. Проверь случаи с достаточным количеством данных, недостаточным количеством данных (должно возвращаться None или вызываться исключение), и известные входные данные с ожидаемым результатом RSI."
    *   **Интеграционные тесты**: Проверяйте взаимодействие между различными компонентами (например, как API эндпоинт вызывает сервис, который в свою очередь обращается к БД).
        *   **Промпт для AI**: "Напиши интеграционный тест для эндпоинта `POST /users/` в `app/api/users.py`. Используй `FastAPI TestClient`. Тест должен проверить успешное создание пользователя и корректность ответа. Используй мок для функции `get_db`, чтобы предоставить тестовую сессию БД (можно использовать SQLite in-memory для тестов)."
    *   **Тестируйте крайние случаи и обработку ошибок**: Убедитесь, что код корректно обрабатывает неверные входные данные, ошибки от внешних API, проблемы с БД и т.д.

3.  **Используйте моки (Mocks) и заглушки (Stubs)**:
    *   При тестировании функций, которые зависят от внешних систем (API BingX, Hector RAG, БД), используйте моки (например, `unittest.mock.patch` в `pytest`) для изоляции тестируемого кода и имитации поведения зависимостей.
    *   Это позволяет тестировать логику вашего компонента независимо от доступности или состояния внешних сервисов.

4.  **Пошаговая проверка и отладка**:
    *   Используйте отладчик Cursor AI (или стандартный `pdb`/`ipdb`) для пошагового выполнения сгенерированного кода, особенно если его логика сложна или неочевидна.
    *   Проверяйте значения переменных на каждом шаге.

5.  **Ручное тестирование API**:
    *   После реализации API эндпоинтов, тестируйте их вручную с помощью инструментов вроде Postman, Insomnia, или даже `curl`. FastAPI также предоставляет интерактивную документацию Swagger UI (`/docs`) и ReDoc (`/redoc`), где можно тестировать эндпоинты прямо в браузере.

6.  **Итеративная доработка**:
    *   Если сгенерированный код не работает или работает некорректно, не бойтесь его изменять или просить AI-агента его переделать.
    *   **Конкретизируйте проблему**: "Функция `generate_signal` возвращает ошибку `TypeError` при таких-то входных данных. Пожалуйста, исправь ее. Вот трейсбек ошибки: [вставьте трейсбек]".
    *   Разбивайте доработку на мелкие шаги.

7.  **Рефакторинг**:
    *   После того как функционал заработает, вернитесь к коду (возможно, с помощью AI) для рефакторинга: улучшения читаемости, удаления дублирования (DRY), оптимизации производительности, приведения к стандартам PEP 8.
    *   **Промпт для AI**: "Проанализируй этот код в файле `app/services/some_service.py`. Есть ли здесь дублирование кода? Если да, предложи варианты рефакторинга для его устранения."

8.  **Проверка безопасности**:
    *   Особенно для приложения, работающего с финансами и внешними API, обращайте внимание на потенциальные уязвимости: SQL-инъекции (хотя ORM снижает этот риск), небезопасная обработка входных данных, утечка API-ключей (используйте переменные окружения!).
    *   Хотя AI может помочь написать код, он не всегда учитывает все аспекты безопасности. Здесь требуется ваш экспертный контроль.

9.  **Логирование**: 
    *   Добавьте подробное логирование на разных этапах работы вашего приложения. Это поможет отслеживать ошибки и понимать поведение бота в production.
    *   **Промпт для AI**: "В функции `process_payment` добавь логирование на уровне INFO в начале выполнения и на уровне DEBUG для ключевых переменных. В случае исключения, логируй ошибку на уровне ERROR вместе с трейсбеком."

10. **Сохраняйте версии (Git)**:
    *   Регулярно коммитьте изменения в Git после каждого успешно реализованного и протестированного небольшого блока функционала. Это позволит легко откатываться к предыдущим рабочим состояниям, если что-то пойдет не так.

Тестирование и доработка — это непрерывный процесс. Систематический подход к проверке кода, сгенерированного AI, поможет вам построить надежное и качественное приложение.
