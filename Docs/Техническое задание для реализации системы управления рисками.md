# Техническое задание для реализации системы управления рисками

## Общее описание

Система управления рисками - это критически важный компонент AI трейдинг-бота, который отвечает за защиту капитала, определение оптимального размера позиций и автоматизацию установки стоп-лоссов и тейк-профитов. Эта система должна интегрироваться с сервисом обмена и сервисом торговли для обеспечения безопасной и контролируемой торговли.

## Структура класса

```python
class RiskManagementService:
    def __init__(self, db: Session, exchange_service: Optional[BingXExchangeService] = None):
        # Инициализация сервиса
        pass

    def calculate_position_size(self, signal: Signal, account_balance: float, risk_percentage: float) -> float:
        # Расчет размера позиции на основе риска
        pass

    def calculate_stop_loss(self, signal: Signal, entry_price: float, atr_value: Optional[float] = None) -> float:
        # Расчет уровня стоп-лосса
        pass

    def calculate_take_profit(self, signal: Signal, entry_price: float, stop_loss: float) -> float:
        # Расчет уровня тейк-профита
        pass

    def validate_risk_reward_ratio(self, entry_price: float, stop_loss: float, take_profit: float, min_ratio: float = 2.0) -> bool:
        # Проверка соотношения риск/доходность
        pass

    def check_max_open_positions(self, max_positions: int = 5) -> bool:
        # Проверка максимального количества открытых позиций
        pass

    def check_correlation(self, new_symbol: str, open_positions: List[Trade], max_correlation: float = 0.7) -> bool:
        # Проверка корреляции с открытыми позициями
        pass

    def calculate_drawdown(self, trades: List[Trade]) -> float:
        # Расчет текущей просадки
        pass

    def check_max_drawdown(self, trades: List[Trade], max_drawdown_percentage: float = 10.0) -> bool:
        # Проверка максимальной просадки
        pass

    def adjust_signal_parameters(self, signal: Signal) -> Signal:
        # Корректировка параметров сигнала на основе риск-менеджмента
        pass

    def validate_trade(self, signal: Signal, account_balance: float) -> Tuple[bool, str]:
        # Комплексная проверка сигнала перед выполнением торговли
        pass

    def monitor_open_trades(self, open_trades: List[Trade]) -> List[Dict[str, Any]]:
        # Мониторинг открытых позиций и рекомендации по управлению
        pass
```

## Детальные требования к методам

### 1. `__init__`

- **Параметры**:
  - `db`: Сессия базы данных
  - `exchange_service`: Сервис для взаимодействия с биржей (если None, создается новый)
- **Действия**:
  - Инициализировать атрибуты класса
  - Сохранить ссылки на сессию базы данных и сервис обмена
  - Настроить логирование

### 2. `calculate_position_size`

- **Параметры**:
  - `signal`: Объект сигнала
  - `account_balance`: Баланс аккаунта
  - `risk_percentage`: Процент от баланса для риска (например, 1%)
- **Действия**:
  - Рассчитать размер риска в абсолютном выражении (account_balance \* risk_percentage / 100)
  - Определить расстояние до стоп-лосса в процентах
  - Рассчитать размер позиции: risk_amount / (entry_price \* stop_loss_percentage)
  - Проверить минимальный размер позиции для биржи
  - Вернуть размер позиции

### 3. `calculate_stop_loss`

- **Параметры**:
  - `signal`: Объект сигнала
  - `entry_price`: Цена входа
  - `atr_value`: Значение индикатора ATR (Average True Range) (опционально)
- **Действия**:
  - Если сигнал уже содержит стоп-лосс, использовать его
  - Если предоставлено значение ATR, рассчитать стоп-лосс на основе ATR (например, entry_price - 2\*atr_value для BUY)
  - Иначе использовать фиксированный процент от цены входа (например, 2%)
  - Вернуть уровень стоп-лосса

### 4. `calculate_take_profit`

- **Параметры**:
  - `signal`: Объект сигнала
  - `entry_price`: Цена входа
  - `stop_loss`: Уровень стоп-лосса
- **Действия**:
  - Если сигнал уже содержит целевую цену, использовать ее
  - Иначе рассчитать целевую цену на основе соотношения риск/доходность (например, 1:3)
  - Для BUY: entry_price + 3 \* (entry_price - stop_loss)
  - Для SELL: entry_price - 3 \* (stop_loss - entry_price)
  - Вернуть уровень тейк-профита

### 5. `validate_risk_reward_ratio`

- **Параметры**:
  - `entry_price`: Цена входа
  - `stop_loss`: Уровень стоп-лосса
  - `take_profit`: Уровень тейк-профита
  - `min_ratio`: Минимальное соотношение риск/доходность (по умолчанию 2.0)
- **Действия**:
  - Рассчитать потенциальный риск: abs(entry_price - stop_loss)
  - Рассчитать потенциальную доходность: abs(take_profit - entry_price)
  - Рассчитать соотношение: reward / risk
  - Вернуть True, если соотношение >= min_ratio, иначе False

### 6. `check_max_open_positions`

- **Параметры**:
  - `max_positions`: Максимальное количество открытых позиций (по умолчанию 5)
- **Действия**:
  - Получить количество открытых позиций из базы данных
  - Вернуть True, если количество открытых позиций < max_positions, иначе False

### 7. `check_correlation`

- **Параметры**:
  - `new_symbol`: Символ новой торговой пары
  - `open_positions`: Список открытых позиций
  - `max_correlation`: Максимальная допустимая корреляция (по умолчанию 0.7)
- **Действия**:
  - Получить исторические данные для new_symbol и символов из open_positions
  - Рассчитать корреляцию между new_symbol и каждым символом из open_positions
  - Вернуть True, если все корреляции < max_correlation, иначе False

### 8. `calculate_drawdown`

- **Параметры**:
  - `trades`: Список сделок
- **Действия**:
  - Рассчитать кумулятивную прибыль/убыток для всех сделок
  - Найти пиковое значение кумулятивной прибыли
  - Рассчитать текущую просадку: (peak - current) / peak \* 100
  - Вернуть процент просадки

### 9. `check_max_drawdown`

- **Параметры**:
  - `trades`: Список сделок
  - `max_drawdown_percentage`: Максимальная допустимая просадка в процентах (по умолчанию 10%)
- **Действия**:
  - Рассчитать текущую просадку с помощью метода calculate_drawdown
  - Вернуть True, если текущая просадка < max_drawdown_percentage, иначе False

### 10. `adjust_signal_parameters`

- **Параметры**:
  - `signal`: Объект сигнала
- **Действия**:
  - Проверить и скорректировать стоп-лосс и целевую цену сигнала
  - Проверить и скорректировать уверенность сигнала на основе риск-менеджмента
  - Вернуть скорректированный сигнал

### 11. `validate_trade`

- **Параметры**:
  - `signal`: Объект сигнала
  - `account_balance`: Баланс аккаунта
- **Действия**:
  - Проверить максимальное количество открытых позиций
  - Проверить корреляцию с открытыми позициями
  - Проверить максимальную просадку
  - Проверить соотношение риск/доходность
  - Вернуть кортеж (is_valid, reason), где is_valid - булево значение, а reason - строка с причиной отказа (если is_valid = False)

### 12. `monitor_open_trades`

- **Параметры**:
  - `open_trades`: Список открытых сделок
- **Действия**:
  - Получить текущие цены для всех символов из open_trades
  - Рассчитать текущую прибыль/убыток для каждой сделки
  - Проверить, достигнуты ли уровни стоп-лосса или тейк-профита
  - Сформировать рекомендации по управлению каждой позицией
  - Вернуть список словарей с информацией о каждой позиции и рекомендациями

## Особенности реализации

### 1. Стратегии управления рисками

Реализовать несколько стратегий управления рисками:

1. **Фиксированный процент**:

   - Риск на сделку: фиксированный процент от баланса (например, 1%)
   - Стоп-лосс: фиксированный процент от цены входа (например, 2%)
   - Тейк-профит: фиксированное соотношение риск/доходность (например, 1:3)

2. **ATR-based**:

   - Риск на сделку: фиксированный процент от баланса
   - Стоп-лосс: на основе индикатора ATR (например, 2\*ATR)
   - Тейк-профит: на основе соотношения риск/доходность

3. **Адаптивная**:
   - Риск на сделку: зависит от уверенности сигнала и волатильности
   - Стоп-лосс: зависит от волатильности и уровней поддержки/сопротивления
   - Тейк-профит: зависит от волатильности и уровней поддержки/сопротивления

### 2. Управление капиталом

Реализовать методы управления капиталом:

1. **Фиксированный процент**:

   - Риск на сделку: фиксированный процент от баланса

2. **Метод Келли**:

   - Риск на сделку: рассчитывается по формуле Келли на основе исторической успешности сигналов

3. **Пирамидинг**:
   - Увеличение размера позиции при движении цены в прибыльном направлении

### 3. Управление позициями

Реализовать методы управления позициями:

1. **Трейлинг-стоп**:

   - Перемещение стоп-лосса вслед за движением цены в прибыльном направлении

2. **Частичное закрытие**:

   - Закрытие части позиции при достижении определенных уровней прибыли

3. **Усреднение**:
   - Добавление к позиции при движении цены против позиции (с осторожностью)

## Интеграция с другими компонентами

### 1. Интеграция с `BingXExchangeService`

- Использовать `BingXExchangeService` для получения баланса аккаунта и открытых позиций
- Использовать `BingXExchangeService` для размещения ордеров с рассчитанными параметрами

### 2. Интеграция с `TradingService`

- Использовать `RiskManagementService` в `TradingService` для валидации сделок перед их выполнением
- Использовать `RiskManagementService` в `TradingService` для расчета размера позиций и уровней стоп-лосса и тейк-профита

### 3. Интеграция с базой данных

- Сохранять параметры риск-менеджмента для каждой сделки
- Сохранять историю изменений стоп-лоссов и тейк-профитов

## Рекомендации по тестированию

### 1. Модульные тесты

Создать модульные тесты для каждого метода:

1. Тесты для расчета размера позиции
2. Тесты для расчета стоп-лосса и тейк-профита
3. Тесты для проверки соотношения риск/доходность
4. Тесты для расчета просадки

### 2. Интеграционные тесты

Создать интеграционные тесты:

1. Тесты для интеграции с `BingXExchangeService`
2. Тесты для интеграции с `TradingService`
3. Тесты для интеграции с базой данных

### 3. Бэктестирование

Провести бэктестирование системы управления рисками:

1. Использовать исторические данные для симуляции торговли
2. Сравнить результаты с разными стратегиями управления рисками
3. Оптимизировать параметры на основе результатов бэктестирования

## Примеры использования

### Пример 1: Расчет размера позиции

```python
from app.services.risk_management_service import RiskManagementService
from app.db.models import Signal

# Создание сервиса
risk_service = RiskManagementService(db)

# Создание сигнала
signal = Signal(
    id=1,
    asset_pair="BTC/USDT",
    signal_type="BUY",
    price_at_signal=50000.0,
    target_price=55000.0,
    stop_loss=48000.0,
    confidence_score=0.8,
    status="ACTIVE"
)

# Расчет размера позиции
account_balance = 10000.0  # USDT
risk_percentage = 1.0  # 1% от баланса
position_size = risk_service.calculate_position_size(signal, account_balance, risk_percentage)
print(f"Position size: {position_size} BTC")
```

### Пример 2: Валидация сделки

```python
from app.services.risk_management_service import RiskManagementService
from app.db.models import Signal

# Создание сервиса
risk_service = RiskManagementService(db)

# Создание сигнала
signal = Signal(
    id=1,
    asset_pair="BTC/USDT",
    signal_type="BUY",
    price_at_signal=50000.0,
    target_price=55000.0,
    stop_loss=48000.0,
    confidence_score=0.8,
    status="ACTIVE"
)

# Валидация сделки
account_balance = 10000.0  # USDT
is_valid, reason = risk_service.validate_trade(signal, account_balance)
if is_valid:
    print("Trade is valid")
else:
    print(f"Trade is invalid: {reason}")
```

### Пример 3: Мониторинг открытых позиций

```python
from app.services.risk_management_service import RiskManagementService
from app.db.crud import get_open_trades

# Создание сервиса
risk_service = RiskManagementService(db)

# Получение открытых позиций
open_trades = get_open_trades(db)

# Мониторинг открытых позиций
trade_status = risk_service.monitor_open_trades(open_trades)
for status in trade_status:
    print(f"Trade {status['trade_id']}: {status['recommendation']}")
```

## Дополнительные рекомендации

1. **Безопасность**:

   - Реализовать механизм аварийной остановки торговли при достижении критических уровней просадки
   - Реализовать механизм ограничения максимального размера позиции

2. **Производительность**:

   - Кэшировать результаты расчетов, которые не меняются часто
   - Оптимизировать запросы к базе данных

3. **Масштабируемость**:

   - Проектировать систему с учетом возможности добавления новых стратегий управления рисками
   - Использовать абстракции для общих операций

4. **Мониторинг и логирование**:
   - Логировать все решения системы управления рисками
   - Создать дашборд для мониторинга ключевых метрик риск-менеджмента

## Реализация класса RiskManagementService

Ниже приведен пример реализации класса `RiskManagementService`:

```python
from typing import Dict, List, Optional, Tuple, Any
import logging
import numpy as np
from datetime import datetime, timedelta
from sqlalchemy.orm import Session
from app.db.models import Signal, Trade
from app.db.crud import get_open_trades, get_trades_by_user
from app.services.exchange_service import BingXExchangeService
from app.core.config import settings

logger = logging.getLogger(__name__)

class RiskManagementService:
    """Сервис для управления рисками при торговле"""

    def __init__(self, db: Session, exchange_service: Optional[BingXExchangeService] = None):
        """
        Инициализация сервиса

        :param db: Сессия базы данных
        :param exchange_service: Сервис для взаимодействия с биржей (если None, создается новый)
        """
        self.db = db
        self.exchange_service = exchange_service or BingXExchangeService(
            is_demo=settings.USE_DEMO_ACCOUNT
        )
        logger.info("Risk management service initialized")

    def calculate_position_size(self, signal: Signal, account_balance: float, risk_percentage: float) -> float:
        """
        Расчет размера позиции на основе риска

        :param signal: Объект сигнала
        :param account_balance: Баланс аккаунта
        :param risk_percentage: Процент от баланса для риска (например, 1%)
        :return: Размер позиции
        """
        # Расчет размера риска в абсолютном выражении
        risk_amount = account_balance * (risk_percentage / 100)
        logger.info(f"Risk amount: {risk_amount} USDT (based on {risk_percentage}% of {account_balance})")

        # Определение расстояния до стоп-лосса
        entry_price = signal.price_at_signal

        # Если стоп-лосс не указан в сигнале, рассчитываем его
        if not signal.stop_loss:
            stop_loss = self.calculate_stop_loss(signal, entry_price)
        else:
            stop_loss = signal.stop_loss

        # Расчет расстояния до стоп-лосса в процентах
        if signal.signal_type == "BUY":
            stop_loss_distance = (entry_price - stop_loss) / entry_price
        else:  # SELL
            stop_loss_distance = (stop_loss - entry_price) / entry_price

        # Расчет размера позиции
        position_size = risk_amount / (entry_price * stop_loss_distance)

        # Проверка минимального размера позиции для биржи
        # Здесь можно добавить логику для проверки минимального размера позиции

        logger.info(f"Calculated position size: {position_size}")
        return position_size

    def calculate_stop_loss(self, signal: Signal, entry_price: float, atr_value: Optional[float] = None) -> float:
        """
        Расчет уровня стоп-лосса

        :param signal: Объект сигнала
        :param entry_price: Цена входа
        :param atr_value: Значение индикатора ATR (Average True Range) (опционально)
        :return: Уровень стоп-лосса
        """
        # Если стоп-лосс уже указан в сигнале, используем его
        if signal.stop_loss:
            logger.info(f"Using signal's stop loss: {signal.stop_loss}")
            return signal.stop_loss

        # Если предоставлено значение ATR, рассчитываем стоп-лосс на основе ATR
        if atr_value:
            if signal.signal_type == "BUY":
                stop_loss = entry_price - (2 * atr_value)
            else:  # SELL
                stop_loss = entry_price + (2 * atr_value)
            logger.info(f"Calculated stop loss based on ATR: {stop_loss}")
            return stop_loss

        # Иначе используем фиксированный процент от цены входа
        stop_loss_percentage = 0.02  # 2%
        if signal.signal_type == "BUY":
            stop_loss = entry_price * (1 - stop_loss_percentage)
        else:  # SELL
            stop_loss = entry_price * (1 + stop_loss_percentage)

        logger.info(f"Calculated stop loss based on fixed percentage: {stop_loss}")
        return stop_loss

    def calculate_take_profit(self, signal: Signal, entry_price: float, stop_loss: float) -> float:
        """
        Расчет уровня тейк-профита

        :param signal: Объект сигнала
        :param entry_price: Цена входа
        :param stop_loss: Уровень стоп-лосса
        :return: Уровень тейк-профита
        """
        # Если целевая цена уже указана в сигнале, используем ее
        if signal.target_price:
            logger.info(f"Using signal's target price: {signal.target_price}")
            return signal.target_price

        # Иначе рассчитываем целевую цену на основе соотношения риск/доходность
        risk_reward_ratio = 3.0  # 1:3

        if signal.signal_type == "BUY":
            risk = entry_price - stop_loss
            take_profit = entry_price + (risk * risk_reward_ratio)
        else:  # SELL
            risk = stop_loss - entry_price
            take_profit = entry_price - (risk * risk_reward_ratio)

        logger.info(f"Calculated take profit based on risk/reward ratio: {take_profit}")
        return take_profit

    def validate_risk_reward_ratio(self, entry_price: float, stop_loss: float, take_profit: float, min_ratio: float = 2.0) -> bool:
        """
        Проверка соотношения риск/доходность

        :param entry_price: Цена входа
        :param stop_loss: Уровень стоп-лосса
        :param take_profit: Уровень тейк-профита
        :param min_ratio: Минимальное соотношение риск/доходность (по умолчанию 2.0)
        :return: True, если соотношение >= min_ratio, иначе False
        """
        # Расчет потенциального риска
        risk = abs(entry_price - stop_loss)

        # Расчет потенциальной доходности
        reward = abs(take_profit - entry_price)

        # Расчет соотношения
        ratio = reward / risk if risk > 0 else 0

        logger.info(f"Risk/reward ratio: {ratio} (min required: {min_ratio})")
        return ratio >= min_ratio

    def check_max_open_positions(self, max_positions: int = 5) -> bool:
        """
        Проверка максимального количества открытых позиций

        :param max_positions: Максимальное количество открытых позиций (по умолчанию 5)
        :return: True, если количество открытых позиций < max_positions, иначе False
        """
        # Получение количества открытых позиций
        open_trades = get_open_trades(self.db)
        open_positions_count = len(open_trades)

        logger.info(f"Open positions: {open_positions_count} (max allowed: {max_positions})")
        return open_positions_count < max_positions

    def check_correlation(self, new_symbol: str, open_positions: List[Trade], max_correlation: float = 0.7) -> bool:
        """
        Проверка корреляции с открытыми позициями

        :param new_symbol: Символ новой торговой пары
        :param open_positions: Список открытых позиций
        :param max_correlation: Максимальная допустимая корреляция (по умолчанию 0.7)
        :return: True, если все корреляции < max_correlation, иначе False
        """
        # Если нет открытых позиций, корреляция не имеет значения
        if not open_positions:
            return True

        # Получение исторических данных для расчета корреляции
        # В реальном приложении здесь должен быть код для получения исторических данных

        # Для примера используем заглушку
        correlations = {}
        for trade in open_positions:
            symbol = trade.signal.asset_pair.replace('/', '')
            # В реальном приложении здесь должен быть код для расчета корреляции
            correlation = 0.5  # Заглушка
            correlations[symbol] = correlation

        # Проверка корреляции
        for symbol, correlation in correlations.items():
            if correlation >= max_correlation:
                logger.warning(f"High correlation ({correlation}) between {new_symbol} and {symbol}")
                return False

        logger.info(f"All correlations are below threshold ({max_correlation})")
        return True

    def calculate_drawdown(self, trades: List[Trade]) -> float:
        """
        Расчет текущей просадки

        :param trades: Список сделок
        :return: Процент просадки
        """
        # Если нет сделок, просадка равна 0
        if not trades:
            return 0.0

        # Сортировка сделок по времени
        sorted_trades = sorted(trades, key=lambda t: t.entry_time)

        # Расчет кумулятивной прибыли/убытка
        cumulative_pnl = 0.0
        peak = 0.0
        drawdowns = []

        for trade in sorted_trades:
            if trade.pnl is not None:
                cumulative_pnl += trade.pnl
                if cumulative_pnl > peak:
                    peak = cumulative_pnl
                elif peak > 0:
                    drawdown = (peak - cumulative_pnl) / peak * 100
                    drawdowns.append(drawdown)

        # Если нет просадок, возвращаем 0
        if not drawdowns:
            return 0.0

        # Возвращаем максимальную просадку
        max_drawdown = max(drawdowns)
        logger.info(f"Maximum drawdown: {max_drawdown}%")
        return max_drawdown

    def check_max_drawdown(self, trades: List[Trade], max_drawdown_percentage: float = 10.0) -> bool:
        """
        Проверка максимальной просадки

        :param trades: Список сделок
        :param max_drawdown_percentage: Максимальная допустимая просадка в процентах (по умолчанию 10%)
        :return: True, если текущая просадка < max_drawdown_percentage, иначе False
        """
        # Расчет текущей просадки
        current_drawdown = self.calculate_drawdown(trades)

        logger.info(f"Current drawdown: {current_drawdown}% (max allowed: {max_drawdown_percentage}%)")
        return current_drawdown < max_drawdown_percentage

    def adjust_signal_parameters(self, signal: Signal) -> Signal:
        """
        Корректировка параметров сигнала на основе риск-менеджмента

        :param signal: Объект сигнала
        :return: Скорректированный сигнал
        """
        # Проверка и корректировка стоп-лосса
        if not signal.stop_loss:
            signal.stop_loss = self.calculate_stop_loss(signal, signal.price_at_signal)

        # Проверка и корректировка целевой цены
        if not signal.target_price:
            signal.target_price = self.calculate_take_profit(signal, signal.price_at_signal, signal.stop_loss)

        # Проверка соотношения риск/доходность
        if not self.validate_risk_reward_ratio(signal.price_at_signal, signal.stop_loss, signal.target_price):
            # Корректировка целевой цены для обеспечения минимального соотношения
            if signal.signal_type == "BUY":
                risk = signal.price_at_signal - signal.stop_loss
                signal.target_price = signal.price_at_signal + (risk * 2.0)
            else:  # SELL
                risk = signal.stop_loss - signal.price_at_signal
                signal.target_price = signal.price_at_signal - (risk * 2.0)

        logger.info(f"Adjusted signal parameters: stop_loss={signal.stop_loss}, target_price={signal.target_price}")
        return signal

    def validate_trade(self, signal: Signal, account_balance: float) -> Tuple[bool, str]:
        """
        Комплексная проверка сигнала перед выполнением торговли

        :param signal: Объект сигнала
        :param account_balance: Баланс аккаунта
        :return: Кортеж (is_valid, reason), где is_valid - булево значение, а reason - строка с причиной отказа
        """
        # Проверка максимального количества открытых позиций
        if not self.check_max_open_positions():
            return False, "Maximum number of open positions reached"

        # Получение открытых позиций
        open_trades = get_open_trades(self.db)

        # Проверка корреляции с открытыми позициями
        new_symbol = signal.asset_pair.replace('/', '')
        if not self.check_correlation(new_symbol, open_trades):
            return False, "High correlation with existing positions"

        # Получение всех сделок пользователя
        all_trades = get_trades_by_user(self.db, user_id=1)  # Здесь должен быть ID пользователя

        # Проверка максимальной просадки
        if not self.check_max_drawdown(all_trades):
            return False, "Maximum drawdown exceeded"

        # Корректировка параметров сигнала
        adjusted_signal = self.adjust_signal_parameters(signal)

        # Проверка соотношения риск/доходность
        if not self.validate_risk_reward_ratio(
            adjusted_signal.price_at_signal,
            adjusted_signal.stop_loss,
            adjusted_signal.target_price
        ):
            return False, "Risk/reward ratio below minimum threshold"

        # Расчет размера позиции
        position_size = self.calculate_position_size(adjusted_signal, account_balance, settings.DEFAULT_RISK_PERCENTAGE)

        # Проверка минимального размера позиции
        min_position_size = 0.001  # Пример минимального размера позиции
        if position_size < min_position_size:
            return False, f"Position size ({position_size}) below minimum ({min_position_size})"

        logger.info(f"Trade validation passed for signal {signal.id}")
        return True, ""

    def monitor_open_trades(self, open_trades: List[Trade]) -> List[Dict[str, Any]]:
        """
        Мониторинг открытых позиций и рекомендации по управлению

        :param open_trades: Список открытых сделок
        :return: Список словарей с информацией о каждой позиции и рекомендациями
        """
        result = []

        for trade in open_trades:
            # Получение текущей цены
            symbol = trade.signal.asset_pair.replace('/', '')
            current_price = self._get_current_price(symbol)

            if current_price is None:
                logger.warning(f"Could not get current price for {symbol}, skipping trade {trade.id}")
                continue

            # Расчет текущей прибыли/убытка
            if trade.signal.signal_type == "BUY":
                pnl = (current_price - trade.entry_price) / trade.entry_price * 100
            else:  # SELL
                pnl = (trade.entry_price - current_price) / trade.entry_price * 100

            # Формирование рекомендации
            recommendation = ""

            # Проверка достижения целевой цены
            if trade.signal.target_price and (
                (trade.signal.signal_type == "BUY" and current_price >= trade.signal.target_price) or
                (trade.signal.signal_type == "SELL" and current_price <= trade.signal.target_price)
            ):
                recommendation = "Close position (target price reached)"

            # Проверка достижения стоп-лосса
            elif trade.signal.stop_loss and (
                (trade.signal.signal_type == "BUY" and current_price <= trade.signal.stop_loss) or
                (trade.signal.signal_type == "SELL" and current_price >= trade.signal.stop_loss)
            ):
                recommendation = "Close position (stop loss triggered)"

            # Проверка времени в позиции
            elif trade.entry_time and trade.entry_time < datetime.now() - timedelta(days=7):
                recommendation = "Consider closing position (time limit reached)"

            # Проверка трейлинг-стопа
            elif pnl > 2.0:  # Если прибыль больше 2%
                # Расчет нового уровня стоп-лосса (трейлинг-стоп)
                if trade.signal.signal_type == "BUY":
                    new_stop_loss = current_price * 0.99  # 1% ниже текущей цены
                    if new_stop_loss > trade.signal.stop_loss:
                        recommendation = f"Move stop loss to {new_stop_loss}"
                else:  # SELL
                    new_stop_loss = current_price * 1.01  # 1% выше текущей цены
                    if new_stop_loss < trade.signal.stop_loss:
                        recommendation = f"Move stop loss to {new_stop_loss}"

            # Добавление информации о позиции в результат
            result.append({
                "trade_id": trade.id,
                "symbol": symbol,
                "entry_price": trade.entry_price,
                "current_price": current_price,
                "pnl": pnl,
                "stop_loss": trade.signal.stop_loss,
                "target_price": trade.signal.target_price,
                "entry_time": trade.entry_time,
                "recommendation": recommendation
            })

        return result

    def _get_current_price(self, symbol: str) -> Optional[float]:
        """
        Получение текущей цены актива

        :param symbol: Символ торговой пары
        :return: Текущая цена или None в случае ошибки
        """
        try:
            # Здесь должен быть запрос к API биржи для получения текущей цены
            # Для примера используем заглушку
            endpoint = "/api/v1/ticker/price"
            params = {'symbol': symbol}
            response = self.exchange_service._make_request('GET', endpoint, params)
            return float(response.get('price', 0))
        except Exception as e:
            logger.error(f"Error getting current price for {symbol}: {str(e)}")
            return None
```

## Пример использования в TradingService

```python
from app.services.risk_management_service import RiskManagementService
from app.services.exchange_service import BingXExchangeService
from app.db.models import Signal, Trade
from app.db.crud import create_trade, update_trade, get_trades_by_signal
from app.core.config import settings

class TradingService:
    """Сервис для управления торговлей на основе сигналов"""

    def __init__(self, db: Session, exchange_service: Optional[BingXExchangeService] = None):
        """
        Инициализация сервиса

        :param db: Сессия базы данных
        :param exchange_service: Сервис для взаимодействия с биржей (если None, создается новый)
        """
        self.db = db
        self.exchange_service = exchange_service or BingXExchangeService(
            is_demo=settings.USE_DEMO_ACCOUNT
        )
        self.risk_service = RiskManagementService(db, self.exchange_service)
        logger.info(f"Trading service initialized (Demo: {settings.USE_DEMO_ACCOUNT})")

    def process_signal(self, signal_id: int, risk_percentage: float = None) -> Optional[Trade]:
        """
        Обработка сигнала и выполнение торговли

        :param signal_id: ID сигнала для обработки
        :param risk_percentage: Процент от доступного баланса для риска (если None, используется значение из настроек)
        :return: Объект сделки или None в случае ошибки
        """
        from app.db.crud import get_signal_by_id

        # Получение сигнала из базы данных
        signal = get_signal_by_id(self.db, signal_id)
        if not signal:
            logger.error(f"Signal with ID {signal_id} not found")
            return None

        # Проверка статуса сигнала
        if signal.status != 'ACTIVE':
            logger.warning(f"Signal {signal_id} is not active (status: {signal.status})")
            return None

        # Проверка срока действия сигнала
        if signal.expires_at and signal.expires_at < datetime.now():
            logger.warning(f"Signal {signal_id} has expired")
            return None

        # Получение баланса аккаунта
        balances = self.exchange_service.get_account_balance()
        usdt_balance = balances.get('USDT', 0)

        # Валидация сделки с помощью сервиса управления рисками
        is_valid, reason = self.risk_service.validate_trade(signal, usdt_balance)
        if not is_valid:
            logger.warning(f"Trade validation failed for signal {signal_id}: {reason}")
            return None

        # Определение процента риска
        if risk_percentage is None:
            risk_percentage = settings.DEFAULT_RISK_PERCENTAGE

        # Расчет размера позиции
        position_size = self.risk_service.calculate_position_size(signal, usdt_balance, risk_percentage)

        # Преобразование пары активов в формат биржи
        symbol = signal.asset_pair.replace('/', '')

        # Определение стороны ордера
        side = signal.signal_type
        if side not in ['BUY', 'SELL']:
            logger.error(f"Invalid signal type for trading: {side}")
            return None

        # Размещение рыночного ордера
        try:
            order_response = self.exchange_service.place_market_order(symbol, side, position_size)

            # Создание объекта сделки
            trade = Trade(
                signal_id=signal.id,
                entry_price=float(order_response.get('price', signal.price_at_signal)),
                volume=float(order_response.get('executedQty', position_size)),
                entry_time=datetime.now(),
                status='OPEN',
                notes=f"Order ID: {order_response.get('orderId')}"
            )

            # Сохранение сделки в базе данных
            db_trade = create_trade(self.db, trade)
            logger.info(f"Trade created for signal {signal_id}: {db_trade.id}")

            return db_trade
        except Exception as e:
            logger.error(f"Error executing trade for signal {signal_id}: {str(e)}")
            return None
```

Пожалуйста, реализуйте систему управления рисками для AI трейдинг-бота, следуя приведенным выше рекомендациям и примерам кода.
